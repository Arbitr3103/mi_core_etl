#!/bin/bash

# ===================================================================
# ЕЖЕНЕДЕЛЬНЫЙ ETL СКРИПТ ДЛЯ CRON JOB
# Запускается каждый понедельник в 3:00
# Финальная версия с унифицированным запуском команд
# ===================================================================

# --- НАСТРОЙКИ ---
export PYTHONIOENCODING=utf-8 # Устанавливаем кодировку
PROJECT_DIR="/home/vladimir/mi_core_etl" # Абсолютный путь к проекту
LOG_DIR="$PROJECT_DIR/logs"
LOG_FILE="$LOG_DIR/etl_run_$(date +%Y-%m-%d).log"
LOCK_FILE="$PROJECT_DIR/etl_process.lock"

# --- ФУНКЦИЯ ДЛЯ ЗАПУСКА КОМАНД С ЛОГИРОВАНИЕМ ---
run_task() {
    echo "--- $(date): Запускаем: $@ ---"
    # Запускаем команду, перенаправляя ее вывод в наш лог
    "$@"
    # Проверяем код выхода последней команды
    if [ $? -ne 0 ]; then
        echo "❌ ОШИБКА: Команда '$@' завершилась с ошибкой."
        # Можно добавить отправку уведомления в Telegram/email
    else
        echo "✅ Успех: Команда '$@' завершена."
    fi
    echo "" # Пустая строка для читаемости
}

# --- ЗАЩИТА ОТ ПОВТОРНОГО ЗАПУСКА ---
# Проверяем, не запущен ли уже процесс ETL
if [ -f "$LOCK_FILE" ]; then
    # Проверяем, активен ли процесс с PID из lock файла
    LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null)
    if [ -n "$LOCK_PID" ] && kill -0 "$LOCK_PID" 2>/dev/null; then
        echo "⚠️ ETL процесс уже запущен (PID: $LOCK_PID). Выходим."
        exit 1
    else
        echo "🧹 Удаляем устаревший lock файл"
        rm -f "$LOCK_FILE"
    fi
fi

# Создаем lock файл с PID текущего процесса
echo $$ > "$LOCK_FILE"

# Функция для очистки lock файла при завершении
cleanup() {
    echo "🧹 Очищаем lock файл при завершении"
    rm -f "$LOCK_FILE"
}

# Устанавливаем trap для очистки при любом завершении скрипта
trap cleanup EXIT INT TERM

# Создаем папку для логов, если ее нет
mkdir -p "$LOG_DIR"

# Переходим в директорию проекта. Если не получилось - выходим.
cd "$PROJECT_DIR" || exit 1

# --- ОСНОВНАЯ ЛОГИКА СКРИПТА ---

# Весь вывод этого блока будет записан в лог-файл
{
    echo "==================================================="
    echo "Запуск ETL-процесса: $(date)"
    echo "==================================================="

    # Находим абсолютные пути к программам
    GIT_PATH=$(which git)
    PYTHON_PATH="$PROJECT_DIR/venv/bin/python3"
    
    # Проверяем существование Python в виртуальном окружении
    if [ ! -f "$PYTHON_PATH" ]; then
        echo "ПРЕДУПРЕЖДЕНИЕ: Виртуальное окружение не найдено, используем системный Python"
        PYTHON_PATH=$(which python3)
    fi

    # 1. ОБНОВЛЕНИЕ КОДА
    run_task "$GIT_PATH" pull

    # 2. УСТАНОВКА ЗАВИСИМОСТЕЙ
    run_task "$PYTHON_PATH" -m pip install -r requirements.txt

    # 3. ЗАГРУЗКА ДАННЫХ ИЗ ИСТОЧНИКОВ
    # Запускаем main.py для Ozon и WB за последние 7 дней
    run_task "$PYTHON_PATH" main.py --last-7-days

    # 4. АГРЕГАЦИЯ ДАННЫХ
    # Запускаем скрипт-агрегатор. Он сам найдет, какие дни обработать.
    run_task "$PYTHON_PATH" run_aggregation.py

    echo "==================================================="
    echo "Завершение ETL-процесса: $(date)"
    echo "==================================================="

} >> "$LOG_FILE" 2>&1
